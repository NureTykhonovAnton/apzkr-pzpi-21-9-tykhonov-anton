Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для управління евакуації населення в надзвичайних ситуаціях

Студент гр. ПЗПІ-20-7		 __________________ Тихонов А. О.
(підпис)
Керівник роботи 			___________________ ст.викл. Сокорчук І.П.
(підпис) 
Роботу захищено «__»_________2023 р.
з оцінкою _________________________ 

Комісія: 				___________________ доц. Лещинський В.О. 
(підпис)
___________________ доц. Лещинська І.О. 
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)


Харків
2024 р.
Харківський національний університет радіоелектроніки 

Факультет комп’ютерних наук Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення		
Курс                     3                     Семестр 	                  6 		
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА ЛАБОРАТОРНІ РОБОТИ СТУДЕНТОВІ
1. Тема проєкту: Програмна система управлінням евакуації населення в надзвичайних ситуаціях
2. Термін узгодження завдання з лабораторних робіт «18»березня 2024 р.
3. Термін здачі завдання з лабораторних робіт «06»червня 2024 р.
4. Вихідні дані по проєкту 5 звітів з виконання лабораторних робіт, розроблена та функціонуюча програмна система що складається з backend, frontend, mobile та IoT частин, демо-відео роботи програми
5. Зміст звітів з лабораторних робіт (перелік питань, що належить розробити) Vision & Scope Document, аркуш завдання, веб-портал для клієнтів та аналітиків, клієнтської серверна частина обробки клієнтської інформації, серверна частина обробки та контролю даних проекту, клієнтської серверна частина обробки IoT, package для інтеграції пристроїв IoT.
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси)для 2 лабораторної роботи: діаграма розгортання, діаграма прецедентів, ER-модель даних, діаграма компонентів, для 3 роботи: діаграма прецедентів, діаграма взаємодій, діаграма діяльності, діаграма компонентів, для 4 роботи: діаграма прецедентів, діаграма компонентів, діаграма станів, діаграма діяльності, для 5 роботи: діаграма прецедентів, компонентів, станів, діяльності.
 
КАЛЕНДАРНИЙ
ПЛАН
№	Основні етапи виконання проекту в рамках лабораторних робіт 	Термін виконання етапів	Примітка
1	Затвердження теми	18.09.24	Виконав
2	Виконання та захист лабораторної роботи №1	18.09.24-12.04.24	Виконав
3	Виконання та захист лабораторної роботи №2	12.04.24-26.04.24	Виконав
4	Виконання та захист лабораторної роботи №3	26.04.24-16.05.24	Виконав
5	Виконання та захист лабораторної роботи №4	16.05.24-29.05.24	Виконав
6	Виконання та захист лабораторної роботи №5	29.05.24-06.06.24	Виконав
7	Захист проекту	30.06.24	Виконав


Дата видачі теми проекту «18» березня 2024 р.


Викладач лабораторних робіт _________ ст. викл. Сокорчук І.П.
(підпис)

Завдання прийняв до виконання ____________ ст.гр. ПЗПІ-21-9 Тихонов А.О.
(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 99 с., 30 рис., 3 таблиці, 3 додатків, 6 джерел.
ЕВАКУАЦІЯ НАСЕЛЕННЯ, АДМІНІСТРУВАННЯ СИСТЕМИ, РОЗУМНИЙ ПРИСТРІЙ, ПРОГРАМНА СИСТЕМА, НЕБЕЗПЕКА, НБ, РОЗРАХУНОК КООРДИНАТ, ПОШТОВИЙ СЕРВІС, МАПА.

Об'єктом дослідження є сфера безпеки населення, що включає у себе контроль за місцями виникнення непередбачуваних ситуацій, методологію проведення евакуації, попередження населення про небезпеки, а також контроль за перебігом евакуації. Для реалізації проекту було обрано тему автоматизації попередження про небезпеку за допомогою поштового сервісу та під’єднаних пристроїв до ІоТ-девайсу та висвітлення зони небезпеки на мапі. Програмній системі було дано назву “SSfMPEiES”, що є акронімом, на англійській мові, теми курсового проекту. На даний момент, система підтримує 3 мови: українську, англійську та іврит. Для івриту було створено адаптацію інтерфейсу, відповідно до напрямку читання тексту на цій мові. Також, система підтримує дві одиниці виміру відстані: метричну та імперичну(американську). Система має дві кольорові теми інтерфейсу.
	У результаті виконання курсового проекту було розроблено наступні ключові частини системи: серверна частина керування даними (бєк-енд), розроблену на мові програмування JavaScript з використанням фреймворку Express.js, реляційної бази даних Sqlite3, та ORM фреймворку Sequelize  для контролю та адміністрування даними з БД; серверна частина сервісу мап, яка використовує постачальника послуг HEREMaps; клієнтська частина і веб-інтерфейс створений за допомогою фреймворку React.js; серверна частина для ІоТ пристрою, створена на FastAPI, що сполучає серверну частину контролю даних да ІоТ пристрій; ІоТ пристрій, що запрограмований мовою C++, і реалізує функціонал сповіщення та повідомлення про небезпеку, а також контроль над вмістом газу у приміщенні. Використовуючи ці компоненти, було створено систему контролю евакуації населення у надзвичайних ситуаціях. 
 
ЗМІСТ

ВСТУП	7
1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	10
1.1	Бізнес-вимоги	10
1.1.1	Бізнес-можливості	10
1.1.3	Потреби клієнтів або ринку	14
1.1.4	Бізнес-ризики	15
1.2	Концепція рішення	16
1.2.1	Окреслення концепції	16
1.2.2	Головна функціональність	18
1.2.3	Припущення та залежності	20
1.3	Рамки та обмеження проекту	21
1.4	Бізнес-контекст	28
2	АНАЛІЗ ВИМОГ ТА СПЕЦИФІКАЦІЯ СИСТЕМИ	35
2.1	Типи користувачів та їх функціонал	35
2.1.1	Зареєстрований користувач	35
2.1.2	Адміністратор	36
2.2	Загальний функціонал системи	37
3	ПРОЕКТУВАННЯ БАЗИ ДАНИХ СИСТЕМИ	37
3.1	Розробка ER-діаграм	37
3.2	Опис сутностей, їх полів та взаємозв’язків	38
3.3	Опис зв’язків між сутностями	41
4	АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	42
4.1	Загальна архітектура системи	42
4.2	Архітектура серверної частини	43
4.2.1	Специфікація REST API	45
4.3	Архітектура клієнтської частини	48
4.4	Архітектура ІоТ-пристрою	53
4.5	Взаємодія користувачів з системою	56
5	ОПИС ІНТЕРФЕЙСУ ТА ФУНКЦІОНАЛЬНОЇ СИСТЕМИ	58
5.1	Вхід та реєстрація до системи	58
5.2	Створення зони НБ	60
5.3	Створення центру евакуації	62
5.4	Створення ІоТ-пристрою	63
5.5	Управління зонами НБ	64
5.6	Управління евакуаціями	65
5.7	Управління типами НБ	65
5.8	Управління центрами евакуації	66
5.9	Управління ІоТ	66
5.10	Логування подій та збереження БД	67
5.11	Зміна мови інтерфейсу	67
5.12	Зміна одиниць виміру довжини	69
5.13	Зміна кольорової теми інтерфейсу	70
ВИСНОВКИ	71
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	72
ДОДАТОК А	73
ДОДАТОК Б	87
ДОДАТОК В	93
ДОДАТОК Г	99

 
ВСТУП


	Протягом свого існування людство завжди перебувало у небезпеці. В залежності від того, який тип небезпеки переслідував людство – ми завжди знаходили засоби реакції до неї. Але небезпеки мають особливість з’являтися несподівано, і до моменту, коли якісь протиборчі заходи можуть бути вжиті, багато людей може вмерти. Смерть людей за собою несе не тільки горе втрати, але й економічні наслідки для потерпілого регіону. Якщо багато людей загине через надзвичайну ситуацію – регіон, де вони проживали, може стати спустошеним.
Тому, задля попередження таких ситуацій, людство з давніх давен вживало різнобічні засоби передчасного повідомлення про небезпеку. У доісторичні часи – великі сигнальні багаття, у Середні віки – дзвін церкви і, з появою електроніки у часи Першої Світової, гучномовці. Серед методів повідомлення населення про небезпеку, а саме передача повідомлення по мережі провідного мовлення (через квартири і зовнішні гучномовці), мережі радіомовних станцій і телебачення, пересувні автомобілі, оснащені гучномовцями – повідомлення через гучномовці та сирени були виявлені найефективнішими, через швидкість їх встановлення та ефективність їх дії на великі відстані.
Головною передумовою для створення цього проекту стало військове вторгнення Російської федерації до України. Хроніка подій.
 Якщо ж брати останні події в Україні, а саме: військове вторгнення Російської федерації, то можна сказати, що потреби в засобах повідомлення про надзвичайні ситуації, а також методи ефективної евакуації населення є потрібними як ніколи. Кількість загиблих га 2023 рік досягла 10 тисяч осіб, серед яких майже 500 дітей. Було знищено вщент багато населених пунктів, серед яких найбільш значною втратою стало місто Маріуполь. Тому цей проект націлений на забезпечення нашої країни а також кожного користувача цієї системи ефективними засобами заподіяння втрат серед населення у випадках надзвичайних ситуацій засобами первинного усунення, або зменшення небезпеки, а також засобами сприяння евакуації. Методами багатофакторного аналізу ми хочемо запобігти цим небезпекам.

Беручи до уваги події в Світі:
З наростанням ефектів парникових газів і глобальним потеплінням, кількість природних катаклізмів збільшиласямайже в 5 разів. До цих катаклізмів відносять: масові лісові пожежі(Пожежа в Каліфорнії, 2020р.), паводки(Наводнення в Бангладеш,) та цунамі. Задля збереження населення у всьому Світі, система, що розробляється, має відповідати потребам у таких надзвичайних ситуаціях.
Особливістю проєкту повинно стати його автономність у прийнятті рішень та децентралізованість. З клієнтської сторони проєкт повинен мати змогу розширювати список можливих клієнтів-гаджетів за допомогою власного фреймворку. З сторони компанії розробника проєкт повинен надавати аналітичну інформацію та виконувати комерційну роль. Також важливою частиною проекту буде проведення польових тестових досліджень ефективності рішень, що розроблюються. А, з-за того, що проєкт націлений на децентралізацію своїх ключових компонентів, у разі пошкодження одного з них через надзвичайну ситуацію – мережа з систем залишається цілою, і для дотичних до пошкодженої систем компонентів надається більший пріоритет у визначені небезпеки при аналізі. Також варто сказати про те, що розгортаючи нашу систему, підприємства в регіоні можуть зменшити негативні економічні наслідки, що можуть виникнути при руйнуванні у наслідку надзвичайних ситуації, тим, що матимуть інформацію з детекторів про можливі загрози. 
 

Згадуючи про існуючі рішення:
На даний момент у Світі представлено велику кількість готових рішень, що задовольняють поставлені умови неменше ніж на 50%. До таких рішень відносяться: Telegrafia, AJAX, Konexus та інші. До їх недоліків можна віднести лише регіональне розповсюдження, вузький спектр послуг, а також ряд інших особливостей, що зменшують спектр та обсяг надання функціональних рішень до представленої проблеми, а методи монетизації обмежені декількома варіантами.

 
	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
	 	Бізнес-вимоги
	Бізнес-можливості


Системи управлінням евакуації населення в надзвичайних ситуаціях використовуються державами та підприємцями скрізь, але, зазвичай, такі рішення не є продуктами комерційної організації, що її випускає. Такі системи доволі часто є комбінацією компонентів, датчиків та пристроїв-замінників, що об’єднуються спеціалістами не за фахом прямо на місці роботи. Зазвичай такі системи є дуже локальними, виконують одну, дуже обмежену роль і не є придатними до масштабування за потреби користувача.
Наша система має наступні аналоги: 
Telegrafia(посилання) – ця компанія постачає на ринок дороге, спеціалізоване обладнання для управлінням евакуації. Воно має високу якість, надійність, а також має широкий рівень інтеграції і різні системи. Їх основний функціонал полягає в створенні системи сповіщення, що з’єднується з місцевим сервером, який координує дію гаджетів ІоТ. Також вони мають об’ємний список пристроїв, що вони підтримують. Хоча мінуси їх системи майже не існують, але через ціну їх розповсюдження не набуло масового характеру. Загалом, від цього аналогу наш проект і буде відштовхуватися. Монетизація цього проєкту полягає у повномасштабному керованому розгортанні системи, продажу окремих компонентів та готових рішень..
AJAX(посилання) – ця компанія, в основному, постачає на ринок IoT прилади для захисту від шахраїв та контролю за периметром. Хоча вони і мають декілька продуктів для попередження надзвичайних ситуацій, але їх системи не націлені на виконання саме такої, поставленої нами, мети. Їх головна функціональність полягає у створенні системи «розумного будинку», методами з’єднання датчиків з одним керуючим пристроєм. Їх мінус полягає у тому, що їх предметна область лише частково відповідає наданій проблемі, що наш проєкт намагається вирішити. Монетизація цього проєкту полягає у продажі комплектуючих та готових рішень.
Konexus(посилання) – ця компанія надає клієнтське програмне забезпечення для телефонів та браузерів з метою оповіщення населення про надзвичайні ситуації. Їх головною відмінністю від нашого проєкту є – відсутність серверної частини для клієнту і функціоналу IoT гаджетів, що зменшує можливості знаходження та відслідковування факторів надзвичайних ситуації. З іншого боку, їх клієнтська мобільна частина має значні переваги над тим, що ми плануємо розробити. Монетизація цього проєкту полягає у розповсюдженні ПО.
Запропонована програмна система матиме ряд переваг над існуючими рішеннями:
По-перше, вона буде комплексно відстежувати всі ключові параметри за допомогою датчиків(навіть від конкурентів) і на їх основі, локально приймати рішення у випадку появи небезпеки(на приклад, опускати залізні ставні при повітряній тривозі).
По-друге, система матиме розширену сумісність через API з наявними детекторами.
По-третє, система зможе надавати аналітику для нашої компанії і клієнтів, що допоможе відслідковувати зміну чинників небезпеки.
Модель монетизації такого продукту може бути різною. Одним із варіантів є продаж ліцензій на використання програмного забезпечення для центрів моніторингу надзвичайних ситуацій за моделлю SaaS(посилання). В такому випадку, стандартною тарифною одиницею буде користувач-пристрій. Таким користувачем може бути IoT гаджет, що під'єднаний до мережі. Такий варіант надання послуг може бути корисним для малих бізнесів, що хочуть доєднатися до національної системи сповіщення, тощо. В первинний пакет послуг, що надається разом із покупкою ліцензії, включено встановлення гаджету та консультування з налаштовування системи. Іншим варіантом розповсюдження продукту є продаж ключів-лицензії, які будуть присутні всередині системи, фізично, частково реалізуючи структуру IaaS(посилання) (Апаратні ключі). У першому випуску продукту планується надати мінімальний функціонал, що можна монетизувати, а саме: розгортання системи, під’єднання клієнтів, адміністрування системи. Також як валідний метод монетизації можна представити плани. У самому базовому плані, клієнт буде отримувати: дизайн та кооперація з створення проєкту, ціновий план для встановлення датчиків, обмежена кількість безкоштовних професіональних консультацій. Загалом, очікується, що при такій стратегії проєкт окупить власну вартість через 3 роки при середньому потоку клієнтів. Очікуваний доход залежить від регіону, буде проведено регуляцію цін в залежності від ВВП країни.
Цільова аудиторія проекту – власники малих та великих бізнесів, національні установи, поодинокі користувачі у віковому проміжку від 18 до 99 років. 
Для власників малого бізнесу наша система надає перевагу інтеграції в загальну систему, таким чином, працівники такого бізнесу будуть сповіщенні про можливу небезпеку. 
Для власників великих бізнесів наш проєкт дозволить створити велику систему з датчиків та заходів уникнення надзвичайних ситуацій, а також долучитися до загальної системи сповіщення. 
Для національних установ ми пропонуємо встановлення тих компонентів системи, що пов’язують і надають інтерфейс до підключених розгорнутих проектів у інших клієнтів нашої компанії. Таким чином, національні установи стануть медіатором у сфері сповіщення у своєму регіоні, що в свою чергу дозволить розділити географічні площини і віддати контроль за ними міським громадам.
Для поодиноких користувачів, що зацікавлені нашою системою, ми можемо надати інструменти для впровадження системи, такі, як інтерактивний конструктор на географічній карті, а також окремі індивідуальні компоненти системи за потреби.
Встановлення вікових обмежень було зроблено, щоби впевнитися у адекватності та платоспроможності майбутнього клієнта.


	Бізнес-цілі та критерії успіху


Бізнес-цілі даного проекту:

BO-1: Досягнути рентабельності та окупності інвестицій у розробку програмної системи протягом 5-9 років після запуску.
BO-2: Забезпечити клієнтів системою сповіщення, що буде відповідати геометричній площині їх об’єкту(розмір території на якій буде розгортатися система).
BO-3: Налагодити партнерські відносини з виробниками датчиків, контролерів та .апаратури, протягом 2-5 років.
ВО-4: Створення програмної оболонки що можна розширювати. На основі цієї оболонки, створити спільноту програмістів-ентузіастів. Залучення таких ентузіастів буде відбуватися методами створення форумів та публічних заходів. 
Критерії успіху даного проекту:

SC-1: Залучити перших корпоративних клієнтів та досягти бази користувачів у кілька тисяч протягом перших 36 місяців після запуску.
SC-2: Стати визнаним лідером на ринку систем управління евакуації населення в надзвичайних ситуаціях протягом 5-6 років.
SC-3: Забезпечити виживання корпоративного персоналу або населення в надзвичайних ситуаціях, за умови сплаченої ліцензії за продукт, на 75-95%.
SC-4: Досягти рівня задоволеності користувачів за рахунок позитивних відгуків та високих оцінок на незалежних платформах оцінювання (вище 8 з 10).


	Потреби клієнтів або ринку


Виділимо основні потреби користувачів:

- Забезпечити своєчасне повідомлення своїх працівників про небезпеку.
- Задіяти першочергові методи боротьби з небезпекою за допомогою гаджетів..
- Мати можливість індивідуального налаштування параметрів факторів, що розпізнаються системою як небезпечні.
- Отримувати зворотний зв'язок та рекомендації щодо покращення умов праці на основі даних, отриманих з детекторів.
- Запобігти створенню умов для небезпеки, функціоналом гаджетів.

Основні потреби корпорацій та організацій:

- Утворити масив користувачів, що залежать від системи.
- Отримувати аналітичні дані та звіти про можливі чинники надзвичайних ситуацій, місце їх настання, а також інтенсивність.
- Створити позитивний імідж компанії.
- Забезпечити відповідність вимогам норм та стандартів серед систем, що напряму впливають на здоров’я та добробут людини, систем безпеки.


	Бізнес-ризики


Опишемо основні бізнес-ризики, які можуть виникнути при розробці та впровадженні програмної системи для управлінням евакуації населення в надзвичайних ситуаціях:
- Фінансові ризики, пов'язані з високою вартістю розробки та інтеграції системи з різними датчиками та обладнанням. Ступінь ризику: середній. Методами мінімізації є ретельне планування бюджету, пошук інвесторів та партнерів, а також грамотна стратегія монетизації продукту.
- Ризики невідповідності стандартам та нормативам щодо захисту безпеки та протидії первинним загрозам. Ступінь ризику: середній. Вирішується шляхом ретельного дослідження відповідних стандартів та тісної співпраці з експертами в галузі охорони праці.
- Ризики недостатнього попиту на ринку через низьку обізнаність клієнтів про переваги системи. Ступінь ризику: високий. Методами боротьби є проведення ефективної маркетингової кампанії, демонстрація результатів пілотних проектів та надання переконливих доказів ефективності рішення.
- Ризики конкуренції з боку існуючих рішень або нових гравців на ринку. Ступінь ризику: Високий. Вирішується за допомогою постійного вдосконалення продукту, впровадження інновацій та забезпечення високої якості обслуговування клієнтів, а також локальною популяризацією і агресивною маркетинговою компанією.


		Концепція рішення
	Окреслення концепції


Головною метою цього проекту є створення рішення проблеми евакуації населення у надзвичайних ситуаціях, з урахуванням невиконаних функціональних проблем конкурентів на ринку. До цих проблем ми виносимо: слабке міжнародне поширення, відсутність професійного консультування для розгортання проекту. Останній пункт, на жаль, є лише частковою проблемою, так, як в наших конкурентів вже існує цей функціонал, але ми хочемо його розширити, додавши: повне ведення проєкту від початку дизайну - до повного втілення, щорічна атестація проєкту за мірками безпеки, виклик професіоналів з регіональних центрів за потреби, та створення механізму підтримки на основі FAQ та спільноти. Наша цільова аудиторія включає в себе: малі бізнеси, середні бізнеси, великі бізнеси, національні установи з безпеки життя населення, некомерційні організації, технічно-наукові спільноти. 
Використання нашої системи допоможе запобігти негативному впливу факторів, що утворюють небезпечні для життя ситуації. До можливостей відслідковування факторів належать: детектори газів, детектори диму на вогню, детектори забруднення води, сейсмічні датчики. Також, до цієї системи можна буде приєднати програмні та апаратні комплекси відслідковування та попередження лісових пожарів, напливу цунамі та метеорологічні міні-станції.
Апаратний комплекс проекту, на ранніх єтапах розвитку, має відслідковувати інтенсивність наступних факторів: кількість СО_2 в повітрі, кількість СО в повітрі, тиск атмосферний у мм.рт.ст., магнітуда коливань сейсмічного маятника. Ці дані будуть передаватися до контролеру ІоТ, де буде перевірятися їх відповідність поставленим нормам у вигляді математичних обчислень. Ці норми, можуть буди налаштовані користувачем. Потім, у випадку перевищення норм, контролер буде давати команду відповідному гаджету-клієнту ІоТ, який буде боротися з фактором небезпеки. У разі перебою зв’язку з гаджетом-клієнтом, або при низькій ефективності його роботи, або при виконанні умов непереборності, дані з контролеру відправляються на сервер контролю контролерів ІоТ методами TCP/UDP/HTTP протоколів, який в свою чергу відправляє команду «Тривога» на усі гаджети-клієнти, що розташовані у його локальній комп’ютерній мережі. Цей ланцюжок дій дозволить отримати дані з датчиків, опрацювати і моментально отреагувати на фактори на контролерах, і передати дані для аналізу та логування на сервер контролю ІоТ. 
Для керівництва компаній система забезпечить доступ до аналітичних даних та рекомендацій щодо оптимізації розташування датчиків та гаджетів звукового попередження, що допоможе приймати обґрунтовані рішення на основі вищезгаданої аналітики та раціонально використовувати ресурси при розгортанні системи. Цей функціонал допоможе аналітикам компанії зробити оцінку території клієнтів для розгортання проекту, і зробити правильний вибір датчиків для спостереження за цією територією. Він буде реалізований за допомогою комбінації порівняння історії минулих небезпек та катаклізмів, географії місцевості та вже існуючих та розгорнутих систем в регіоні. Також, буде представлено низку засобів контролю окремих гаджетів ІоТ, перевірки системи, інтеграції системи з доступними рішеннями, та дистанційного активування системи, створення підсистем-гілок, для розподілення навантаження та ієрархії.


	Головна функціональність


Виділимо основну функціональність програмної системи евакуації населення у надзвичайних ситуаціях:

MF-1: Моніторинг факторів небезпеки (температура, вологість, атмосферний тиск, рівень СО_2  та СО, відхилення від стандартів сейсмічної магнітуди тощо) в режимі реального часу за допомогою зовнішніх датчиків. Дані з датчиків будуть передаватися на сервер ІоТ для подальшої обробки та прогнозування. Ця функція системи є критичною і має самий високий первинний пріоритет при розробці системи.
MF-2: Управління методами сповіщення населення(мобільний додаток, випливаючи повідомлення на ПК, звукове повідомлення гучномовцем).
MF-3: Аналіз взаємозв'язку факторів небезпеки з очікуваним часом настання небезпеки, побудова плану поширення небезпеки на географічній території за допомогою алгоритмів машинного навчання.
MF-4: Задіяння превентивних дій до настання небезпеки(сповіщення, закривання залізних перешкод, тощо).
MF-5: Інтеграція з методами сповіщення населення в повсякденному житті(використання гучномовців для програвання реклами товарів, або у якості радіо). Це розширить функціонал системи, що дозволить, і зменшить час простою системи у вільний час.
MF-6: Генерування рекомендацій для керівництва щодо покращення умов праці на основі аналізу зібраних даних(для підприємств газових господарств). Система генерування буде використовувати штучний інтелект за методом підкріпленого навчання
MF-7: Формування аналітичних звітів про моментальний та довготривалий вплив факторів на економіку регіону.
MF-8: Веб-портал та мобільний додаток для перегляду поточного стану регіону, активних небезпек та можливості громадянського повідомлення про небезпеку.
MF-9: Налаштування відображення екстрених сповіщень.
MF-10: Буферизація та шифрування даних за допомогою наявних методів шифрування(Симетричне шифрування, публічні та приватні ключі, шифри SHA256).

 
	Припущення та залежності


Припущення:
AS-1: Наявність необхідної інфраструктури (датчики, мережа, серверне обладнання) для розгортання системи.
AS-2: Можливість інтеграції з існуючими системами та обладнанням.
AS-3: Достатня кількість актуальних даних для ефективного навчання моделей машинного навчання для побудови карти можливих небезпек.
AS-4: Відкритість співробітників до використання системи та надання зворотного зв'язку.

Залежності:
D-1: Функціональність системи залежить від якості та точності детекторів та встановленого максимального відхилення від норм.
D-2: Ефективність оптимізації залежить від коректного навчання моделей машинного навчання на репрезентативних даних.
D-3: Функціональність системи з сторони клієнта залежить від типу ліцензії, на яку він підписаний.
D-4: Прийняття системи користувачами залежить від зручності використання, простоти та швидкості розгортання та легкості налаштування системи.
 
	 	Рамки та обмеження проекту
	Рамки первинного випуску


Описуючи рамки первинного випуску для програмної системи управлінням евакуації населення в надзвичайних ситуаціях було взято базовий пакет послуг, що буде надаватися клієнтові. Для кращого опису системи, його було розділено на частини за програмною реалізацією, а саме: головна серверна частина системи(компанія), клієнтська частина(компанія), серверна частина(клієнт), клієнтська частина(клієнт). Потрібно розуміти, що первинний випуск не націлений на реалізацію функціоналу, що дозволило б масштабувати систему.

Розпочнемо із функціональності серверної частини для нашої компанії:

- Реєстрація та підтвердження користувачів на основі  JSON WebToken, з проміжком життя у 24 години. Розподілення за ролями наступне: незареєстрований користувач(гість), зареєстрований користувач(клієнт компанії), адміністратор(працівник компанії).
- Створення, збереження та архівування даних про клієнтів, розгорнуті системи і логування активних небезпечних ситуацій на сервері компанії.
- Локалізація інтерфейсу для різних мов та країн.
- Захист даних за допомогою шифрування.
- Аналіз та передбачення настання надзвичайних ситуацій на інтерактивній карті регіону.
- Автоматична розсилка повідомлень про небезпеку до серверів клієнтів, а також клієнтських застосунків працівників компанії в залежності від налаштувань.
- Адміністрування системи та управління правами доступу.
Функціональність клієнтської частини для компанії, що відбуватиметься тільки на веб-застосунку:
- Реєстрація та підтвердження користувачів з сервером компанії.
- Веб-сторінка для реклами продукції компанії.
- Адмін-панель для управління ролями користувачів.
- Панель для розсилки повідомлень на пошту клієнтів.
- Панель з аналізом даних по клієнтам, продажам, небезпекам.
- Автоматична розсилка оповіщень про небезпеку до серверів клієнтів(цей функціонал буде виділено на окремий рівень у наступних випусках проекту, в цілях децентралізації).
- Панель контролю налаштування сповіщень про небезпеку. 
 
Функціональність серверної частини для клієнту:
- Реєстрація та підтвердження користувачів з сервером клієнту.
- Збір та збереження даних з контролерів IoT гаджетів.
- Аналіз даних з контролерів IoT гаджетів і автоматична реакція на перевищення значення факторів небезпеки. Аналіз відбуватиметься у вигляді перевірки на перевищення значення вхідних даних з детекторів.
- Автоматична розсилка повідомлень про небезпеки на клієнтські застосунки(мобільний та веб-застосунок) отриманих з контролерів ІоТ або з регіонального розподіленого серверу контролю за небезпеками або з серверу нашої компанії.

Функціональність клієнтської частини для клієнту, що відбуватиметься на веб-застосунку:
- Адмін-панель для контролю ІоТ контролерами.
- Панель з аналізом повідомлень від ІоТ контролерів і мобільних клієнтів.
- Панель контролю налаштування сповіщень про небезпеку. 

Функціональність клієнтської частини для клієнту, що відбуватиметься на мобільному застосунку:
- Реєстрація та підтвердження користувачів з сервером клієнтської частини.
- Панель сповіщень про небезпеку.
- Мапа укриття та горизонту небезпеки.

Функціональність IoT частини:

- Збір даних про фактори небезпеки (температура, рівень CO тощо) за допомогою датчиків. Ці дані будуть збиратися в проміжках часу, визначених клієнтом, і можливим для датчиків.
- Контроль показників датчиків у реальному часі.
- Передача зібраних даних на сервер для подальшої обробки та аналізу.

Кожна з клієнтських частин(компанія, клієнт) матиме наступну додаткову функціональність:
- Локалізація та інтернаціоналізація мов.
- Підтримка різних форматів тексту, напрямів його написання, тощо.
Системна мережа буде шифруватися наявними методами шифрування(Симетричне шифрування, публічні та приватні ключі, шифри SHA256).
Потоки даних будуть дублюватися у критичних секціях(буферизація). В системі буде присутній лог і дублювання ключових даних бази даних методом RAID.
 

	Рамки наступних випусків


Функціонал, що буде розвиватися у наступних версіях проекту(1.1):
	Підтримка більшого різноманіття датчиків та інтегрованих систем. Цей перелік включає у себе інтеграцію з системами Telegrafia і використання датчиків AJAX. Також буде створено та розширено список датчиків та систем, що будуть інтегруватися. Таким чином, при інтеграції датчиків AJAX, можливе розширення системи у напрямку безпеки та контролю персоналу, або території підприємства, на якому встановлено систему. Цей функціонал включатиме: відеофіксацію, систему контролю доступу працівників, безпека периметру підприємства за допомогою інфрачервоних датчиків руху. Буде розширено список факторів, які будуть досліджуватися і аналізуватися. Також, деякі наявні фактори будуть винесені в категорія – так, фактори температури повітря та його вологості будуть винесені у метеорологічні фактори, що впливають на небезпеку. Загалом, буде проведена категоризація факторів та їх зв’язування.
	Створення регіональних розподільчих систем для оповіщення про небезпеки(див. функціональність клієнтської частини для компанії). Це створить мережу систем сповіщення, що будуть передавати повідомлення про небезпеку між собою.
	Надання нового типу клієнтського застосунку - АРІ. Його функціонал дозволить робити виклики на гучномовці, детектори та засоби усунення факторів небезпеки через консоль та у програмних застосунках розроблених клієнтами. Це дозволить більш тонко використовувати як програмну так і апаратну базу системи. Це напряму розширить функціонал проєкту, так як дозволить створювати власні застосунки для розширення існуючого функціоналу проєкту.
	У наступному випуску буде встановлена пріоритизація на розвиток протоколів та методів зв’язування розподілених систем, встановлених клієнтами. Головним пріоритетом буде вирішення проблеми безперервної комунікації з детекторами( планується надати перевагу протоколу UDP з додатковими методами безпеки та контролю потоку даних), і створення методів більш ефективної буферизації.


	Обмеження та винятки


Під час експлуатації системи можуть виникнути різноманітні винятки та обмеження, які важливо враховувати на етапі проектування та розробки. Розглянемо їх детальніше.

Винятки, пов'язані з мережевою інфраструктурою та живленням:

Перебої в мережевому з'єднанні або доступі до Інтернету та серверів можуть призвести до тимчасової втрати зв'язку із системою моніторингу та неможливості аналізу на сервері компанії. Для мінімізації цього ризику слід передбачити резервні канали зв'язку та резервні джерела живлення.
Нестабільне або переривчасте живлення неефективного електричного обладнання, задіяного в системі, може спричинити втрату даних та збій в роботі. Необхідно забезпечити надійні джерела безперебійного живлення.
Збій в роботі обладнання та датчиків:

Відмова або пошкодження датчиків та інших параметрів призведе до втрати даних з певних зон моніторингу. Система повинна мати функції самодіагностики та сповіщення про несправності.

Обмеження, пов'язані з інтеграцією та сумісністю:

Система повинна бути сумісною з існуючими BMS, обладнанням різних виробників та протоколами обміну даними. Це вимагає ретельного аналізу та тестування на етапі проектування.
Бюджетні обмеження можуть вплинути на вибір обладнання, технологій та масштабованість рішення, тому потрібно знайти оптимальний баланс між вартістю та функціональністю.
Обмеження безпеки та конфіденційності:

Система повинна забезпечувати захист персональних даних співробітників відповідно до вимог законодавства та внутрішніх політик компанії.
Необхідно передбачити заходи кібербезпеки для захисту від несанкціонованого доступу, витоку даних та кібератак.
Фізичні обмеження приміщень:

Конструктивні особливості будівлі, розташування робочих зон та перешкоди для поширення сигналів датчиків можуть вплинути на розміщення обладнання та покриття системою.
 
	 	Бізнес-контекст
	Профілі зацікавлених сторін


Таблиця 1.1 – Профілі зацікавлених сторін проекту
Зацікавлена сторона	Головна цінність	Ставлення	Головний інтерес	Обмеження
Керівництво компанії	Створення системи оповіщення та мінімізації небезпеки	Сприймається як захисний засіб	Зменшення втрат серед населення та персоналу, приватної власності. 	Бюджетні обмеження
Відділ ІТ	Забезпечення інтеграції з існуючими системами та їх безпечного спілкування	Сприймається як платформа для розвитку технологій	Забезпечення інтеграції системи	Обмеження інфраструктури та існуючих технології
Фінансовий відділ	Створення фінансово вигідного продукту і його реклама	Сприймається як фінансова можливість	Забезпечення максимального прибутку за одиницю товару	Фінансові обмеження
Постачальники обладнання	Отримання фінансової вигоди з продажу компонентів для системи	Сприймається як фінансова можливість	Забезпечення максимального прибутку за одиницю товару	Обмеження структури компонентів що постачаються
Продовження табл. 1.1  – Профілі зацікавлених сторін проекту
Клієнти	Своєчасне сповіщення про небезпеку	Сприймається як система безпеки 	Забезпечення власної безпеки	Необхідність навчання та під’єднання до нової системи
Відділ охорони праці	Утворення кращих умов безпеки персоналу	Сприймається як метод контролю персоналу у випадках надзвичайних ситуацій	Забезпечення безпеки персоналу	Необхідність інтеграцій нових норм для системи і відслідковування її стану


 
	Пріоритети проекту


Таблиця 1.2 – Пріоритети проекту
Показник	Виконання(етапи)	Обмеження(граничні значення)	Ступінь свободи(допустимий діапазон)
План робіт	Версія 1.0 до 01.09.2023, Версія 1.1 до 15.11.2023	Версія 1.0 -граничний термін 
01.09.2023, Версія 1.1 - граничний термін 15.11.2023	Версія 1.0 –відхилення 
max 7 днів, 
Версія 1.1 –відхилення 
max 14 днів
Функціональність	У версії 1.0:
Превентивні функції, оповіщення, мапа небезпек
У версії 1.1:
Аналіз даних, інтеграція сторонніх систем, АРІ	Реалізація >10% зазначених версій	Більша частина зазначених функцій для 1.0 повинна бути виконана, решта – 1.1
Якість	Забезпечення високої якості продукту, відповідно до вимог безпеки та надійності	Проходження 100% тестів на функціональність, безпеку та продуктивність	Допустиме невиконання до 15% некритичних тестів

Продовження табл. 1.2  – Пріоритети проекту
Персонал	Сформувати основну команду до 21.10.2026	Максимальний розмір команди: 20 розробників, 
3 тестувальники,
2 аналітики	Перевищення персоналу допустиме в рамка від 1 до 5 осіб
Бюджет	Витратити 40% бюджету на версію 1.0, решту на випуск 1.1	Не перевищувати загальний запланований бюджет	Можливе перевищення бюджету на розробку версії 1.0 на 10%

 
	Робоче середовище


Програмна система управління евакуацією населення в надзвичайних ситуаціях буде розподілена на 3 основних рівня багатошарової архітектури. Список інструментів включає:
Express.js: фреймворк для створення веб-додатків на JavaScript з використанням Node.js. Дозволяє швидко створювати серверну частину, обробляти HTTP-запити та взаємодіяти з базою даних. Буде використовуватися для серверної частини клієнту. На нього будуть відправлені запити з мобільної, веб та API версії клієнтів.
Перевага використання цього інструменту полягає у тому, що він доволі простий, швидко та легко інтегрується з веб клієнтською частино, і дозволяє використовувати мову, що підходить для розробки клієнтської частини.
React.js: JavaScript-бібліотека для розробки інтерфейсів користувача. Дозволяє створювати динамічні та ефективні UI-компоненти.
Перевага використання цього інструменту полягає у тому, що він простий у використанні і надзвичайно потужний для розробки веб-інтерфейсів. Його популярність покращує програмну підтримку інструменту, і розвиває споріднені інструменти, що можна в нього інтегрувати.
Redux - це бібліотека для управління станом додатків у JavaScript, часто використовувана в сучасних веб-додатках. Вона забезпечує простий та прогнозований спосіб керування станом, що полегшує розробку та підтримку великих та складних додатків. Цей інструмент обраний для використання у розробці веб-застосунку, щоби спростити, покращити та керувати використанням станів.
Spring Java: фреймворк для розробки на Java. Надає інструменти для створення веб-додатків, мікросервісів, роботи з базами даних тощо. Цей інструмент буде використовуватися для побудови серверу компанії. Перевага використання цього інструменту полягає у тому, що він підтримує великий обсяг систем по усьому Світу, таким чином спрощуючи подальшу інтеграцію.
Python Django: високорівневий фреймворк для розробки веб-додатків на Python. Забезпечує швидке створення додатків з системою управління БД, аутентифікацією та маршрутизацією. Цей інструмент буде використовуватися для побудови серверу контролю контролерів ІоТ. Його перевага полягає у тому, що він використовує мову програмування Python, що є стандартом для більш нових контролів, а також ця мова має великий перелік готових рішень для впровадження штучного інтелекту та аналітики, що можна використовувати у купі з контролерами ІоТ.  
Так, як система має багаторівневу та багатошарову архітектуру, то на кожному проміжному етапі передачі даних(від клієнту до серверу, від серверу до серверу, від серверу до бази даних) буде вбудовано балансувальні комплекси. Вони будуть виконувати не тільки роль розділення навантаження на різні сервера, але і виконувати роль безпеки даних за допомогою перевірки даних на цілісність і актуальність шифру. Для балансування на сервери буде використано метод динамічного балансування.
Підтримка з’єднання, а також спілкування між компонентами системи буде відбуватися за допомогою HTTP-запитів і TCP/IP протоколів. До таких компонентів відносяться: всі типи клієнтів, окрім ІоТ-гаджетів, веб-сервери, сервери контролю даних. У випадках використання ІоТ-гаджетів, що потребують прямого і безперервного підключення, будуть використовуватися протокол UDP з вирівнювачем пакетів на обох кінцях.
JWT: стандарт для безпечної передачі даних у вигляді JSON. Використовується для аутентифікації користувачів. Використання цього інструменту важливе для безпеки та контролю даних.
MongoDB: документ-орієнтована база даних, яка зберігає дані у форматі BSON. Підтримує гнучкі схеми та масштабування. Використання цього інструменту полягає у збереженні, контролю та сортуванні даних.
Android Kotlin + JetPack Compose: мова та фреймворк UI для розробки мобільних додатків на Android. Використання цього інструменту полягає у створенні рідного до заліза мобільного клієнтського застосунку. Ця особливість дозволить краще використовувати усі можливості клієнтського пристрою для виконання функцій системи.
Google Maps API: інструменти для взаємодії з картографічними даними та функціями Google Maps. Він необхідний для географічного відображення багатьох елементів системи, аналізу та пророкування даних.
У проекті будуть використовуватися засоби контейнеризації, засобами Docker. А для розгортання та підтримання системи буде використовуватися Kubernetes. Використання цих інструментів обумовлено їх швидким та зручним використанням, а також широкою спільнотою, що дозволить залучити більше професіоналів для вирішення проблем.
Серед хмарних засобів було обрано Microsoft Azure, через спорідненість наданого їм функціоналу до інструментарію цього проєкту. Не виключено, що можливе використання комбінації інших хмарних сервісів за власної потреби клієнтів, або у подальшій розробці проєкту.
Протягом розробки проєкту, набір інструментів може змінюватися.
 
	АНАЛІЗ ВИМОГ ТА СПЕЦИФІКАЦІЯ СИСТЕМИ


На основі аналізу предметної області, було визначено мету цього курсового проекту – створення програмної системи для визначення зон небезпеки та повідомлення користувачів про них, з подальшою евакуацією до центру. Тому база даних повинна мати як мінімум 5 головних таблиці, що відповідають за функціонал: користувач, зона НБ, центр евакуації, евакуація, ІоТ девайс. Для додаткового удосконалення системи було додано таблицю з типами небезпек, що містить у собі назву та інструкцію з евакуації.


	 Типи користувачів та їх функціонал


Система має два типи користувачів: зареєстрований користувач та адміністратор. Адміністратор має усі функціональні можливості зареєстрованого користувача, а тому до переліку його функціональних можливостей це прописуватися ще раз не буде. Також є незареєстрований користувач, але його функціонал полягає лише у можливості реєстрації або вхожу до системи.


	Зареєстрований користувач


а) вхід до системи або повторна реєстрація;
б) перегляд та завантаження мапи;
в) перегляд та редагування профілю;
г) створення зони НБ на мапі;
д) отримання повідомлення про небезпеку на пошту.


	Адміністратор


а) редагування та видалення зони НБ;
б) створення, редагування та видалення центрів евакуацій;
в) створення, редагування та видалення ІоТ девайсів;
г) створення, редагування та видалення користувачів;
ґ) створення, редагування та видалення типів НБ;
д) створення, редагування та видалення евакуацій;
е) перегляд та збереження логів;
є) дублювання (бєкап) бази даних.

 
	 Загальний функціонал системи


а) зміна мови інтерфейсу;
б) зміна одиниць виміру інтерфейсу;
в) зміна кольорової теми інтерфейсу.


	ПРОЕКТУВАННЯ БАЗИ ДАНИХ СИСТЕМИ
	 Розробка ER-діаграм


При проектуванні системи контролю евакуації населення з надзвичайних ситуацій було розроблено базу даних і ER-діаграму сутностей і зв’язків між цими даними. Діаграма наведена на рис. 3.1.

Рисунок 3.1 – ЕR-діаграма бази даних системи контролю евакуації населення з надзвичайних ситуацій
	Опис сутностей, їх полів та взаємозв’язків


а) User(Користувач)

id: унікальний ідентифікатор користувача системи
username: ім’я користувача
email: потова скринька користувача
password: пароль до облікового запису користувача
img: іконка аватару користувача
role: роль користувача
longitude: географічна довгота користувача
latitude: географічна широта користувача
created_at: дата створення запису до бази даних
updated_at: дата останнього оновлення запису бази даних


б) Zone(Зона НБ)

id: унікальний ідентифікатор зони НБ
startedAt: дата початку небезпеки
endedAt: дата кінця небезпеки
emergencyTypeId: ідентифікатор типу небезпеки
name: назва зони НБ
radius: радіус зони НБ
longitude: географічна довгота зони НБ
latitude: географічна широта зони НБ
created_at: дата створення запису до бази даних
updated_at: дата останнього оновлення запису бази даних

в) Center(Евакуаційний центр)

id: унікальний ідентифікатор центру евакуації
name: назва центру евакуації
longitude: географічна довгота центру евакуації
latitude: географічна широта центру евакуації
created_at: дата створення запису до бази даних
updated_at: дата останнього оновлення запису бази даних

г) Evacuation(Евакуація)

id: унікальний ідентифікатор евакуації
startZoneId: ідентифікатор зони НБ, з якої почалась евакуація
endCenterId: ідентифікатор центру евакуації, до якого прокладено маршрут
userId: ідентифікатор користувача, що евакуюється
created_at: дата створення запису до бази даних
updated_at: дата останнього оновлення запису бази даних

ґ) EmergencyType(Тип НБ)

id: унікальний ідентифікатор типу НБ
name: назва типу НБ
description: інструкція для евакуації з зони НБ за цим типом
created_at: дата створення запису до бази даних
updated_at: дата останнього оновлення запису бази даних

д) IoTDevice(ІоТ девайс)

id: унікальний ідентифікатор ІоТ девайсу
MACADDR: МАК адреса ІоТ девайсу
defaultZoneRadius: радіус створеної зони НБ у разі спрацювання датчиків ІоТ девайсу
gasLimit: максимальне значення датчику газу, при якому спрацьовує повідомлення про небезпеку
longitude: географічна довгота ІоТ девайсу
latitude: географічна широта ІоТ девайсу
created_at: дата створення запису до бази даних
updated_at: дата останнього оновлення запису бази даних
 
	 Опис зв’язків між сутностями


User – Evacuation: “один-до-багатьох”. 
Один користувач може приймати участь у багатьох евакуаціях. 
Одна евакуація може мати лише одного користувача.

Zone – Evacuation: “один-до-багатьох”. 
Одна зона НБ може приймати участь у багатьох евакуаціях. 
Одна евакуація може мати лише одну зону НБ.

Center – Evacuation: “один-до-багатьох”. 
Один центр евакуації може приймати участь у багатьох евакуаціях. 
Одна евакуація може мати лише один центр евакуації.

Zone – EmergencyType: “один-до-багатьох”. 
Одна зона НБ  може мати лише один тип небезпеки. 
Один тип небезпеки може бути призначено багатьом зонам НБ.

 
	АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
	 Загальна архітектура системи


Архітектура системи керування евакуацією населення в надзвичайних ситуаціях побудована на багатокомпонентній архітектурі, що забезпечує комунікацію між окремими її частинами і дозволить розширювати систему у майбутньому. З архітектурою системи можна ознайомитися на рис.3.1.


 
Рисунок 4.1 – Діаграма розгортання системи керування евакуацією населення в надзвичайних ситуаціях
 
Відповідно до діаграми розгортання можна побачити, що система складається с наступних частин:
	Клієнтська частина (Веб-клієнт)
	ІоТ частина (ІоТ пристрій (ESP32))
	Серверна частина (Сервер застосунків)

Спілкування між компонентами системи відбувається за допомогою HTTP запитів та WebSocket повідомлень. Взаємодія даних між сервером Express та базою даних SQLite відбувається за допомогою ORM бібліотеки Sequelize .


	 Архітектура серверної частини


Серверна частина системи контролю евакуації населення у надзвичайних ситуаціях має основну монолітну будову, з підпорядкованим їй сервісом для мап. Сервіс для мап (Map service) не працює напряму з бізнес логікою проекту, а є лише проміжним ланцюгом між постачальником географічних послуг HERE Maps та клієнтською частиною проекту. Це було зроблена задля полегшення заміни постачальника, якщо буде така необхідність, а також, це відв’язує частину кодової бази, від основного серверу, що працює з даними.

Основна логіка керується через декілька архітектурних шарів:
	Шар уявлення (API endpoints routers): Реалізований за допомогою фреймворку Axious, що забепечує обробку запитів та формування відповідей. На основі цього шару і технологій побудовано REST API проекту. Додатково обгорнутий у маршрутизатори з Express.js, для кращої класифікації за призначенням.
	Шар бізнес логіки (Controllers): В цьому шарі відбувається керування даними, через методи Sequelize  з моделями ORM. 
	Шар доступу до даних (Models): Використовуючи моделі даних Sequelize  ми можемо працювати з даними, як з JSON об’єктами.

Проміжний функціональний шар у системі складають middleware:
	Система авторизації у систему за допомогою JWT токенів блокує ключові запити на оновлення, видалення та читання даних користувачів без активного та вірного Bearer токену, що під’єднується до кожного HTTP запиту.
	WebSocket Router слугує контролером спілкування між сервером та усіма іншими частинами системи.
	Morgan logger, записує усі запити до серверу та зберігає у окремому файлі, який можна завантажити.

 
	Специфікація REST API


У таблиці (табл. 4.1) наведено усі можливі на даний момент запити до кінцевих точок REST API, що є в системі. Усі основні моделі підтримують повну функціональність CRUD, додаткові функції виконують лише запрограмовану частку.

Табл.4.1 - Специфікація REST API серверу системи контролю евакуації населення з надзвичайних ситуацій.
Сутність	Метод	Посилання	Дія


Center	GET	/api/centers/	Отримання усіх центрів евакуації
	GET	/api/centers/:id	Отримання центру евакуації по id
	POST	/api/centers/	Створення нового центра евакуації
	PUT	/api/centers/:id	Оновлення центра евакуації по id
	DELETE	/api/centers/:id	Видалення центра евакуації по id
EmergencyType	GET	/api/emergency-types/	Отримання усіх типів НБ
	GET	/api/emergency-types/:id	Отримання типу НБ по id
	POST	/api/emergency-types/	Створення нового типу НБ
	PUT	/api/emergency-types/:id	Оновлення типу НБ по id
	DELETE	/api/emergency-types/:id	Видалення типу НБ по id

 
Продовження табл.4.1 - Специфікація REST API серверу системи контролю евакуації населення з надзвичайних ситуацій.
Evacuation	GET	/api/evacuations/	Отримання усіх евакуацій
	GET	/api/evacuations/:id	Отримання евакуації по id
	POST	/api/evacuations/	Створення нової евакуації
	PUT	/api/evacuations/:id	Оновлення евакуації по id
	DELETE	/api/evacuations/:id	Видалення евакуації по id
IoTDevice	GET	/api/iot-devices/	Отримання усіх ІоТ девайсів
	GET	/api/iot-devices/:id	Отримання ІоТ девайсу по id
	POST	/api/iot-devices/	Створення нового ІоТ девайсу
	PUT	/api/iot-devices/:id	Оновлення ІоТ девайсу по id
	DELETE	/api/iot-devices/:id	Видалення ІоТ девайсу по id
User	GET	/api/users/	Отримання усіх користувачів
	POST	/api/users/	Створення нового користувача
	PUT	/api/users/:id	Оновлення користувача по id
	DELETE	/api/users/:id	Видалення користувача по id
	POST	/api/users/login	Аутентифікація користувача за даними
	GET	/api/users/data	Отримання даних користувачів за JWT токеном

 
Продовження табл.4.1 - Специфікація REST API серверу системи контролю евакуації населення з надзвичайних ситуацій.
Zone	GET	/api/zones/	Отримання усіх зон НБ
	GET	/api/zones/:id	Отримання зони НБ по id
	POST	/api/zones/	Створення нової зони НБ
	PUT	/api/zones/:id	Оновлення зони НБ по id
	DELETE	/api/zones/:id	Видалення зони НБ по id
Logger	GET	/logs	Отримання копії логів з серверу
Backupper	POST	/api/backup	Створення дублікату бази даних

 
	Архітектура клієнтської частини


Клієнтська частина проекту створена за допомоги фреймворку React та графічної бібліотеки Material-UI. Фреймворк передбачає використання компонентного стилю розробки із збереженням стану змінних у контекстах.
Для цієї системи було розроблено 5 основних та 1 додатковий контекст, що не виконує функціоналу. До цих контекстів відносяться: 
а) authContext, що керує станом користувача у системі. Завдяки ньому, різні компоненти системи отримують необхідні дані о користувачеві з будь-якого точку у коді.
б) hereMapContext, що керує станом постачальника мап. Завдяки ньому, відбувається завантаження та передача необхідних бібліотек для роботи з мапами.
в) i18nContext, що керує станом перекладу на інші мови. Використовуючи бібліотеку i18n-react, цей контекст реалізує перемальовування тексту компонентів на інші мови. Для цього він використовує завчасно створені файли локалі, що мають у собі необхідні строки перекладу.
г) unitContext, що керує станом зміни числових значень з одної системі вимірів в іншу. Для цього, в контексті прописано конвертор величин.
ґ) themeContext, що керує станом кольорової теми веб-застосунку. Для цього, в контексті прописано світлу и темну теми з параметрами, що передаються до компонентів.
А також, multiProvider, що сполучає декілька контекстів, задля організації коду.

Також, для реалізації більшості функціоналу було розроблено з використанням “гаків”.
Гаки включають у себе виклик важливих функцій і збереження станів, що, також, можна використовувати у будь-якому компоненті. Так, наприклад гак useGeolocation відповідає за отримання з клієнту географічних даних про місцезнаходження, і, використовуючи інший гак useWebsockets, періодично відправляє повідомлення про оновлення місцезнаходження користувача.
На наступній діаграмі, можна побачити усі компоненти, що є на клієнтській частині.

  
Рисунок 4.3.1 – Діаграма компонентів веб-клієнту системи


Зображені на цій діаграмі компоненти - мають різні рівні доступу, так, для неавторизованих користувачів доступно лише WelcomePage та компоненти Header і похідні.

 
Рисунок 4.3.2 – Діаграма прицендентів веб-клієнту системи
 
 
Рисунок 4.3.3 - Діаграма станів веб-клієнту системи
 
 
Рисунок 4.3.4 - Діаграма діяльності веб-клієнту системи
 
	 Архітектура ІоТ-пристрою


ІоТ девайс системи контролю евакуації населення у надзвичайних ситуацях - розроблений на базі мікроконтролера ESP32, симульованого в середовищі Wokwi, з використанням Arduino фреймворку. 

Система включає наступні компоненти:
а) LED-лампу для візуальної індикації, що виконує роль візуального сповіщення;
б) LCD дисплей для відображення поточного статусу під’єднання приладу, а також значень газу;
в) Гучномовець, який працює як сирена для сигналізації тривоги;
г) Кнопка "Небезпека" для ручного запуску процесу евакуації;
ґ) Потенціометр, що імітує роботу вимірювального приладу для визначення рівня газу в приміщенні.
 
 
Рисунок 4.4.1 - Діаграма прецедентів IoT частини системи

 Ці компоненти дозволяють своєчасно сповіщати людей про небезпеку та запускати процес евакуації. Комунікація між IoT-пристроєм та сервером здійснюється за дпомогою WebSoket повідомлень. IoT-пристрій виконує регулярний моніторинг рівня газу, відправку даних на сервер, виконання отриманих команд, відображення статусу на LCD дисплеї, активацію сирени та мигалки, а також автоматичний запуск процесу евакуації при перевищенні показників газу. 

Для візуалізації роботи IoT-компоненту було розроблено UML діаграму активності, яка відображає основні процеси роботи пристрою, включаючи ініціалізацію, підключення до Wi-Fi, встановлення WebSocket з'єднання, цикл моніторингу та відправки даних.

 
Рисунок 4.4.2 –  Діаграма пакетів для IoT частини системи

 
	 Взаємодія користувачів з системою


Система контролю евакуації населення з надзвичайних ситуацій має у своїй основі представлення о декількох ролях користувачів і окрім цього, система також має ІоТ пристрої у якості окремих дійових осіб. Тому для представлення розділених можливостей між дійовими особами, було створено наступну діаграму:

 
Рисунок 4.4 – Діаграма прецедентів системи контролю евакуації населення в надзвичайних ситуаціях

Виходячи з вищезгаданої діаграми:
	Зареєстрований користувач може сповіщати про небезпеку за допомогою встановлення зони НБ на мапі, та отримувати повідомлення про небезпеку на поштову скриньку, вказану при реєстрації.
	Адміністратор має повний набір функцій користувача, а також повний доступ до створення, редагування та видалення усіх записів з усіх сутностей БД. Адміністратор також є єдиною роллю, що може робити прямі маніпуляції с базою даних, такі, як наприклад дублювання БД.
	ІоТ пристрій має функціональні можливості і обмеження в залежності від компонентів, які до нього приєднані. В даній конфігурації, ІоТ пристрій може здійснювати моніторинг показників газу у приміщенні, а також повідомляти користувачів про небезпеку.
 
	ОПИС ІНТЕРФЕЙСУ ТА ФУНКЦІОНАЛЬНОЇ СИСТЕМИ
	 Вхід та реєстрація до системи


Для роботи у системі користувач повинен мати обліковий запис.
У разі, якщо такого запису немає – користувач має можливість створити його, натиснувши кнопку реєстрації на хедері головного екрану.

Рисунок 5.1.1 - Форма реєстрації до системи


Після натискання підтвердження, користувачу потрібно буде увійти до свого нового облікового запису. Для цього потрібно натиснути кнопку входу.


Рисунок 5.1.2 - Форма входу до системи


Після цього, користувача перенесе до сторінки з мапою.
 
	 Створення зони НБ


Після входу до облікового запису, користувачу буде показана мапа з його місцезнаходженням у цьому географічному регіоні.
Зліва зверху на мапі буде знаходитися опція вибору додавання нової зони НБ. Потрібно обрати цю опцію та натиснути на позицію на мапі.
Справа зверху розташований лічильник координат для курсору миші. Значення написані у коробці це довгота та широта, відповідно. Біля нього – кнопка завантаження мапи.
Знизу посередині розташований компонент, що висвітлює доступні евакуаційні центри та зони НБ, відповідно. Переключення між таблицями здійснюється за допомогою натискання на інформативні кнопки.

 
Рисунок 5.2.1 – Компонент мапи
 
При обиранні опції додавання нової зони НБ та натискання на вільне місце на карті, перед користувачем висвітиться модальне вікно з полями, які потрібно заповнити.

 
Рисунок 5.2.2 – Модальне вікно створення зони НБ


Після цього, на карті з’явиться коло зони НБ заданого радіусу.
 
	 Створення центру евакуації


Адміністратор системи має доступ до схожого компоненту мапи, але з більшими можливостями. Однією з таких можливостей є створення центру евакуації. Для цього, як і користувачу, адміністратору потрібно обрати опцію з перелічених та натиснути на точку на мапі. Після чого, з’явиться модальне вікно створення центру евакуації.

 
Рисунок 5.3.1 – Модальне вікно створення центру евакуації


По натисканню кнопки створення, на мапі з’явиться маркер центру евакуації.
 
	 Створення ІоТ-пристрою


Адміністратор системи має можливість створити ІоТ пристрій на мапі. Для цього потрібно обрати опцію з перелічених та натиснути на точку на мапі. Після чого, з’явиться модальне вікно створення ІоТ пристрою.

 
Рисунок 5.4.1 – Модальне вікно створення ІоТ пристрою


По натисканню кнопки створення, на мапі з’явиться маркер ІоТ пристрою.
 
	 Управління зонами НБ


Адміністратор має можливість керування даними зон НБ. Для цього на сайдбарі, йому потрібно буде обрати Зони НБ.

 
Рисунок 5.5.1 – Вікно сайдбару


Після цього, на екрані з’явиться компонент керування даними зон НБ.

 
Рисунок 5.5.2 – Компонент керування зонами НБ
 
	 Управління евакуаціями


Адміністратор має можливість керування даними евакуацій. Для цього на сайдбарі, йому потрібно буде обрати Зони НБ і натиснути на стрілку вниз. З’явиться підменю, де потрібно обрати Евакуації.

 
Рисунок 5.6.1 – Компонент керування евакуаціями


	 Управління типами НБ


Адміністратор має можливість керування даними типів НБ. Для цього на сайдбарі, йому потрібно буде обрати Зони НБ і натиснути на стрілку вниз. З’явиться підменю, де потрібно обрати Типи НБ.

 
Рисунок 5.7.1 – Компонент керування типами НБ
 

	 Управління центрами евакуації


Адміністратор має можливість керування даними центрів евакуації. Для цього на сайдбарі, йому потрібно буде Центри.

 
Рисунок 5.8.1 – Компонент керування центрами


	 Управління ІоТ


Адміністратор має можливість керування даними ІоТ пристроями. Для цього на сайдбарі, йому потрібно буде ІоТ.


 
Рисунок 5.9.1 – Компонент керування ІоТ пристроями
 
	Логування подій та збереження БД


Адміністратор системи може переглядати логи обрав відповідну вкладинку на сайдбарі. Окрім цього, він може завантажити логи у текстовому форматі собі на комп’ютер, або віддалено зберегти копію бази даних на сервері.

 
Рисунок 5.10.1 – Компонент логів та функціоналу дублювання БД


	Зміна мови інтерфейсу


Будь-який користувач може обрати мову за допомогою випадаючого меню на хедері. Для цього потрібно натиснути на кнопку у вигляді шестерні, після чого вибрати опцію

 
Рисунок 5.11.1 – Випадаюче меню з мовами
Так, як український інтерфейс був продемонстрований на інших рисунках, тому виберемо дві інші мови, а саме: англійську та іврит.

 
Рисунок 5.11.2 – Сторінка лендінгу англійською мовою


 
Рисунок 5.11.3 – Сторінка лендінгу івритом
 
	Зміна одиниць виміру довжини


Користувач може змінювати одиницю виміру довжини х метричної та імперичну, і дані будуть перемальовуватися в залежності від вибраної опції.

 
Рисунок 5.12.1 – Значення дистанції в метричному виді 


 
Рисунок 5.12.2 - Значення дистанції в імперичному виді 
 
	Зміна кольорової теми інтерфейсу
Також користувач може змінювати кольорову тему інтерфейсу у випадаючому меню у хедері.

 Рисунок 5.13.1 – Зміна кольору сайдбару при іншій кольоровій темі


 Рисунок 5.13.2 – Зміна компоненту мапи при іншій кольоровій темі
 
ВИСНОВКИ


В результаті виконання курсової роботи було створено програмну систему для контролю евакуації населення в надзвичайних ситуаціях. Система розроблена з використанням різноманітних технологій, що охоплюють кожну окрему частину проекту. Було використано такі фреймворки як React, Express, FastAPI, тощо. Були задіяні бібліотеки Sequelize  , Morgan, haversine, Axious, і багато інших.
Створена система є гарним прикладом проекту, що може розвиватися. Але навіть на поточному часі, він задоволняє базові потреби у функціоналі з обраної теми. Система підтримує функціональність оповіщення населення через звукові сигнали та інші види повідомлень, що дозволяє оперативно реагувати на зміну ситуації. Крім того, реалізована можливість визначення найближчих евакуаційних центрів з урахуванням поточного місцезнаходження користувача, що сприяє більш швидкому і безпечному пересуванню в зоні надзвичайної ситуації.
В цілому, створена програмна система є ефективним інструментом для організації та управління процесом евакуації в умовах надзвичайних ситуацій. Вона значно підвищує рівень безпеки населення та ефективність дій рятувальних служб, сприяючи зниженню ризиків і збереженню життя в кризових ситуаціях.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. Material-UI Blog: Insights and Updates. URL: https://mui.com/blog/
(дата звернення: 16.07.2024).
2. React Patterns: A collection of design patterns/techniques used while 
developing with React. URL: https://github.com/reactpatterns/reactpatterns (дата 
звернення: 3.06.2024).
3. IoT For All: Internet of Things (IoT) News, Resources, and Thought 
Leadership. URL: https://www.iotforall.com/ (дата звернення: 12.08.2024).
4. Express Docs URL: https://expressjs.com/ (дата звернення: 8.08.2024).
5.Sequelize  Docs URL: https://Sequelize .org/docs/v6/getting-started/ (дата звернення: 8.08.2024).
6. Відеозапис тестування функціоналу на YouTube: https://www.youtube.com/watch?v=vEq2XztPXAw
 
ДОДАТОК А
Код серверної частини системи

А.1 Логіка прийняття веб-сокет повідомлень

1	/**
2	WebSocket message handling module.
3	* 
4	@module wsRouter
5	*/
6	const User = require('../models/user');
7	const IoTDevice = require('../models/iotDevice');
8	const { checkIfUserWithinZone } = require('../middlewares/geolocationCheck');
9	const WebSocket = require('ws');
10	const { where } = require('sequelize');
11	/**
12	Defines the handlers for different WebSocket message types.
13	* 
14	@type {Object}
15	@property {Function} userLocationUpdate - Handles updates to user location.
16	@property {Function} init - Handles initialization of IoT devices.
17	*/
18	const wsRouter = {
19	/**
20	Handles updates to user location.
21	* 
22	@param {Object} data - The data sent with the WebSocket message.
23	@param {WebSocket} connection - The WebSocket connection object.
24	@async
25	@throws {Error} Throws error if updating user location fails.
26	*/
27	'userLocationUpdate': async (data, connection) => {
28	try {
29	const { userId, latitude, longitude } = data;
30	// Validate latitude and longitude
31	if (typeof latitude !== 'number' || typeof longitude !== 'number') {
32	console.error('Invalid latitude or longitude');
33	connection.send(JSON.stringify({ error: 'Invalid latitude or longitude' }));
34	return;
35	}
36	console.log(`Received location: Latitude - ${latitude}, Longitude - ${longitude} from user: ${userId}`);
37	// Find the user by ID
38	const foundUser = await User.findByPk(userId);
39	if (!foundUser) {
40	console.error('User not found');
41	connection.send(JSON.stringify({ error: 'User not found' }));
42	return;
43	}
44	// Update user location
45	await foundUser.update({ longitude, latitude });
46	// Check if the user is within a zone
47	checkIfUserWithinZone(foundUser);
48	console.log('User location updated successfully');
49	connection.send(JSON.stringify({ success: 'User location updated successfully' }));
50	} catch (error) {
51	console.error('Error updating user location:', error);
52	connection.send(JSON.stringify({ error: 'Error updating user location' }));
53	}
54	},
55	/**
56	Handles initialization of IoT devices.
57	* 
58	@param {Object} data - The data sent with the WebSocket message.
59	@param {WebSocket} connection - The WebSocket connection object.
60	@async
61	@throws {Error} Throws error if initialization fails.
62	*/
63	'init': async (data, connection) => {
64	console.log('IoT device init received!');
65	const { MACADDR } = data;
66	try {
67	// Find the IoT device by MACADDR
68	const foundIot = await IoTDevice.findOne({ where: { MACADDR } });
69	if (foundIot) {
70	console.log(`IoT device with MACADDR: ${MACADDR} found!`);
71	connection.send(JSON.stringify(foundIot));
72	} else {
73	console.error('IoT device not found');
74	connection.send(JSON.stringify({ error: 'IoT device not found' }));
75	}
76	} catch (error) {
77	console.error('Error during initialization:', error);
78	connection.send(JSON.stringify({ error: 'Error during initialization' }));
79	}
80	},
81	/**
82	Handles emergency alert from IoT devices and creates a corresponding Zone.
83	* 
84	@param {Object} data - The data sent with the WebSocket message.
85	@param {WebSocket} connection - The WebSocket connection object.
86	@async
87	@throws {Error} Throws error if Zone creation fails.
88	*/
89	'emergencyAlert': async (data, connection) => {
90	console.log('Emergency alert received from IoT device!');
91	const { MACADDR } = data;
92	try {
93	// Find the IoT device by MACADDR
94	const foundIot = await IoTDevice.findOne({ where: { MACADDR } });
95	if (foundIot) {
96	console.log(`IoT device with MACADDR: ${MACADDR} found! Creating Zone...`);
97	// Create a new Zone based on the IoT device's parameters
98	const newZone = await Zone.create({
99	startedAt: new Date(),
100	emergencyTypeId: 1,
101	name: "IoT created Zone",
102	longitude: foundIot.longitude,
103	latitude: foundIot.latitude,
104	radius: foundIot.defaultZoneRaduis || 500, // Default to 100 if not specified
105	});
106	console.log('Zone successfully created:', newZone);
107	connection.send(JSON.stringify(newZone));
108	} else {
109	console.error('IoT device not found');
110	connection.send(JSON.stringify({ error: 'IoT device not found' }));
111	}
112	} catch (error) {
113	console.error('Error during emergency alert handling:', error);
114	connection.send(JSON.stringify({ error: 'Error during emergency alert handling' }));
115	}
116	},
117	};
118	/**
119	Routes WebSocket messages to appropriate handlers based on message type.
120	* 
121	@param {string} message - The raw WebSocket message.
122	@param {WebSocket} connection - The WebSocket connection object.
123	@throws {Error} Throws error if message parsing or routing fails.
124	*/
125	const routeMessage = (message, connection) => {
126	try {
127	console.log('Raw Message:', message); // Log raw message data
128	const parsedMessage = JSON.parse(message);
129	console.log('Parsed Message:', parsedMessage);
130	const { type, data } = parsedMessage;
131	// Validate that data is not null or undefined
132	if (!data) {
133	console.error('Data is missing in the message');
134	connection.send(JSON.stringify({ error: 'Data is missing in the message' }));
135	return;
136	}
137	if (wsRouter[type]) {
138	wsRouter[type](data, connection);
139	} else {
140	console.error(`No handler for message type: ${type}`);
141	connection.send(JSON.stringify({ error: 'Unrecognized message type' }));
142	}
143	} catch (error) {
144	console.error('Error parsing message:', error);
145	connection.send(JSON.stringify({ error: 'Invalid data format' }));
146	}
147	};
148	module.exports = routeMessage; 

А.2 Код функції розрахунку відстаней 

1	const { Op } = require('sequelize');
2	const haversine = require('haversine-distance');
3	const Zone = require('../models/zone');
4	const User = require('../models/user');
5	const Evacuation = require('../models/evacuation');
6	const Center = require('../models/center');
7	const sendDangerAlertEmail = require('./sendEmail');
8	const EmergencyType = require('../models/emergencyType');
9	/**
10	Checks if a user is within any active emergency zone and handles evacuation if necessary.
11	* 
12	@param {Object} user - The user object containing user details.
13	@param {Object} websocket - The WebSocket connection object to send notifications.
14	* 
15	@returns {Promise<void>} A promise that resolves when the check and notifications are complete.
16	* 
17	@throws {Error} Throws an error if there's an issue finding the user, zones, or handling evacuation.
18	* 
19	@example
20	const { checkIfUserWithinZone } = require('./path/to/this/module');
21	* 
22	checkIfUserWithinZone(user, websocket);
23	*/
24	const checkIfUserWithinZone = async (user, websocket) => {
25	try {
26	const foundUser = await User.findByPk(user.id);
27	if (!foundUser) {
28	throw new Error('User not found');
29	}
30	// Fetch all active emergency zones
31	const activeZones = await Zone.findAll({
32	where: {
33	endedAt: {
34	[Op.is]: null,
35	},
36	},
37	include: [{ model: EmergencyType, as: 'emergencyType' }],
38	});
39	// Iterate through each zone and check if the user is within any zone
40	for (const zone of activeZones) {
41	const userLocation = { latitude: user.latitude, longitude: user.longitude };
42	const zoneLocation = { latitude: zone.latitude, longitude: zone.longitude };
43	const distance = haversine(userLocation, zoneLocation);
44	// Check if user is within the zone's radius
45	if (distance <= zone.radius) {
46	// Check if there is already an evacuation for the user in this zone
47	const existingEvacuation = await Evacuation.findOne({
48	where: {
49	userId: user.id,
50	startZoneId: zone.id,
51	endCenterId: {
52	[Op.not]: null,
53	},
54	},
55	});
56	// If there's already an evacuation, skip further processing
57	if (existingEvacuation) {
58	console.log(`Evacuation already exists for user ${user.username} in zone ${zone.name}.`);
59	break;
60	}
61	// Create an evacuation record for the user
62	const nearestCenter = await findNearestCenter(user.latitude, user.longitude);
63	const evacuation = await Evacuation.create({
64	startZoneId: zone.id,
65	endCenterId: nearestCenter.id,
66	userId: user.id,
67	});
68	// Send a warning to the frontend via WebSocket
69	const warningMessage = {
70	type: 'warning',
71	message: `User ${user.username} is within an emergency zone! Evacuation initiated.`,
72	evacuationDetails: evacuation,
73	};
74	websocket.send(JSON.stringify(warningMessage));
75	// Send an email alert to the user
76	await sendDangerAlertEmail(user, zone);
77	break; // Stop checking other zones since user is already within one
78	}
79	}
80	} catch (error) {
81	console.error('Error checking user within zone:', error);
82	}
83	};
84	/**
85	Finds the nearest evacuation center to the given latitude and longitude.
86	* 
87	@param {number} latitude - The latitude of the user or location to compare.
88	@param {number} longitude - The longitude of the user or location to compare.
89	* 
90	@returns {Promise<Object>} A promise that resolves with the nearest center object.
91	* 
92	@throws {Error} Throws an error if there's an issue finding the centers.
93	* 
94	@example
95	const nearestCenter = await findNearestCenter(user.latitude, user.longitude);
96	*/
97	const findNearestCenter = async (latitude, longitude) => {
98	const centers = await Center.findAll();
99	let nearestCenter = null;
100	let minDistance = Infinity;
101	centers.forEach(center => {
102	const centerLocation = { latitude: center.latitude, longitude: center.longitude };
103	const userLocation = { latitude, longitude };
104	const distance = haversine(userLocation, centerLocation);
105	if (distance < minDistance) {
106	nearestCenter = center;
107	minDistance = distance;
108	}
109	});
110	return nearestCenter;
111	};
112	/**
113	Checks if a user is within 50 meters of the nearest evacuation center and updates evacuation status.
114	* 
115	@param {Object} user - The user object containing user details.
116	@param {Object} websocket - The WebSocket connection object to send notifications.
117	* 
118	@returns {Promise<void>} A promise that resolves when the check and notifications are complete.
119	* 
120	@throws {Error} Throws an error if there's an issue finding the nearest center or updating evacuation.
121	* 
122	@example
123	const { checkUserProximityToCenter } = require('./path/to/this/module');
124	* 
125	checkUserProximityToCenter(user, websocket);
126	*/
127	const checkUserProximityToCenter = async (user, websocket) => {
128	try {
129	const nearestCenter = await findNearestCenter(user.latitude, user.longitude);
130	if (!nearestCenter) {
131	console.log('No centers found.');
132	return;
133	}
134	const userLocation = { latitude: user.latitude, longitude: user.longitude };
135	const centerLocation = { latitude: nearestCenter.latitude, longitude: nearestCenter.longitude };
136	const distance = haversine(userLocation, centerLocation);
137	// Check if the user is within 50 meters of the nearest center
138	if (distance <= 50) {
139	// Send a WebSocket message to notify about proximity
140	try {
141	// Check if an evacuation record exists for the user and nearest center
142	const existingEvacuation = await Evacuation.findOne({
143	where: { endCenterId: nearestCenter.id, userId: user.id }
144	});
145	if (existingEvacuation) {
146	const proximityMessage = {
147	type: 'proximityToCenter',
148	message: `User ${user.username} is within 50 meters of the nearest center. End evacuation?`,
149	centerDetails: nearestCenter,
150	};
151	websocket.send(JSON.stringify(proximityMessage));
152	// Proceed with deletion if an evacuation record exists
153	await Evacuation.destroy({
154	where: { endCenterId: nearestCenter.id, userId: user.id }
155	});
156	console.log(`User ${user.username} is within 50 meters of the nearest center. Evacuation completed.`);
157	} else {
158	// Log a message if no evacuation record is found
159	console.log(`No evacuation record found for user ${user.username} at the nearest center.`);
160	}
161	} catch (error) {
162	console.error('Error handling evacuation:', error);
163	}
164	}
165	} catch (error) {
166	console.error('Error checking user proximity to center:', error);
167	}
168	};
169	module.exports = {
170	checkIfUserWithinZone,
171	checkUserProximityToCenter};


 
ДОДАТОК Б
Код клієнтської частини web

Б.1 Код контексту аунтефікації користувача на фронт-енді

	import React, { createContext, useContext, useState, useEffect } from 'react';
	import { useNavigate } from 'react-router-dom';
	import { deleteUser, fetchUserData } from '../api/userRequests';
	// Create a Context for authentication
	const AuthContext = createContext();
	/**
	Provides authentication state and actions to child components.
	* 
	This component checks for an existing token on mount, retrieves user data
	if the token is valid, and handles navigation based on the user's role.
	It also provides a function to delete the user's account.
	* 
	@param {Object} props - Component properties.
	@param {React.ReactNode} props.children - Child components to be rendered.
	* 
	@returns {React.ReactElement} - The provider component with authentication state.
	*/
	export const AuthProvider = ({ children }) => {
	const [loading, setLoading] = useState(true);
	const [user, setUser] = useState(null);
	const navigate = useNavigate();
	useEffect(() => {
	/**
	Checks for a valid authentication token and fetches user data.
	Redirects to the home page if no token is found or if there is an error
	fetching user data.
	*/
	const checkToken = async () => {
	const token = localStorage.getItem('token');
	if (token) {
	try {
	const userData = await fetchUserData(token);
	setUser(userData);
	} catch (error) {
	console.error('Error checking token:', error);
	navigate('/');
	}
	} else {
	navigate('/');
	}
	setLoading(false);
	};
	checkToken();
	}, [navigate]);
	useEffect(() => {
	/**
	Navigates to a specific page based on the user's role once loading is complete.
	Redirects to the home page if the user's role is unrecognized.
	*/
	if (!loading && user) {
	if (user.role.toLowerCase() === 'admin') {
	navigate('/admin-page');
	} else if (user.role.toLowerCase() === 'user') {
	navigate('/user-page');
	} else {
	navigate('/');
	}
	}
	}, [loading, user, navigate]);
	/**
	Deletes the user's account and clears user data from the state.
	* 
	@async
	@returns {Promise<void>} - A promise that resolves when the account is deleted.
	*/
	const deleteAccount = async () => {
	try {
	await deleteUser(user.id);
	setUser(null); // Clear user data from state
	} catch (error) {
	console.error('Error deleting account:', error);
	}
	};
	return (
	<AuthContext.Provider value={{ user, loading, deleteAccount }}>
	{!loading && children}
	</AuthContext.Provider>
	);
	};
	/**
	Custom hook to access authentication context values.
	* 
	@returns {Object} - The authentication context values including user data, 
	loading state, and account management functions.
	*/
	export const useAuth = () => {
	return useContext(AuthContext);};

Б.2 Код гаку геолокації користувача на фронт-енді

	import { useState, useEffect } from 'react';
	import { useAuth } from '../contexts/authContext';
	import useWebSocket from './useWebSocket';
	import { getEvacuationByUserId } from '../api/evacuationRequests';
	/**
	Custom hook to handle user geolocation, WebSocket communication, and fetching evacuation data.
	*
	@returns {Object} Contains the latitude, longitude, evacuation data, and any error encountered.
	*
	@example
	const { latitude, longitude, evacuationData, error } = useGeolocation();
	*/
	const useGeolocation = () => {
	const [latitude, setLatitude] = useState(null);
	const [longitude, setLongitude] = useState(null);
	const [evacuationData, setEvacuationData] = useState(null);
	const [error, setError] = useState(null);
	const { sendMessage, isConnected } = useWebSocket();
	const { user } = useAuth();
	/**
	Success callback for geolocation API.
	Updates the state with the current position.
	*
	@param {GeolocationPosition} position - The geolocation position object containing coordinates.
	*/
	const handleSuccess = (position) => {
	setLatitude(position.coords.latitude);
	setLongitude(position.coords.longitude);
	};
	/**
	Error callback for geolocation API.
	Logs the error and updates the state with the error message.
	*
	@param {GeolocationPositionError} error - The error object provided by the geolocation API.
	*/
	const handleError = (error) => {
	console.error('Geolocation error:', error);
	setError(error.message); // Store error message in the state
	};

	/**
	Starts tracking the user's location using the browser's geolocation API.
	Fetches the initial position and watches for continuous updates.
	*
	@returns {number|null} The ID of the geolocation watch, or null if geolocation is not supported.
	*/
	const startTracking = () => {
	if (navigator.geolocation) {
	// Fetch initial position
	navigator.geolocation.getCurrentPosition(handleSuccess, handleError);
	// Watch for continuous position updates
	return navigator.geolocation.watchPosition(handleSuccess, handleError);
	} else {
	const errorMsg = 'Geolocation is not supported by this browser.';
	console.error(errorMsg);
	setError(errorMsg);
	return null;
	}
	}
	// Setup geolocation tracking on mount and cleanup on unmount
	useEffect(() => {
	const watchId = startTracking();
	return () => {
	if (navigator.geolocation && watchId !== null) {
	navigator.geolocation.clearWatch(watchId);
	}
	};
	}, []);
	/**
	Sends location updates via WebSocket whenever the latitude or longitude changes.
	*/
	useEffect(() => {
	if (isConnected && latitude !== null && longitude !== null) {
	sendMessage({
	type: 'userLocationUpdate',
	data: {
	userId: user.id,
	latitude,
	longitude,
	},
	});
	}
	}, [latitude, longitude, isConnected, sendMessage, user.id]);
	/**
	Fetches evacuation data for the current user based on their ID.
	The data is fetched only when the user ID is available.
	*/
	useEffect(() => {
	const fetchEvacuationData = async () => {
	try {
	const evacResponse = await getEvacuationByUserId(user.id);
	setEvacuationData(evacResponse);
	console.log("Evacuation received and set:", evacResponse);
	} catch (error) {
	console.error('Error fetching evacuation data:', error);
	}
	};
	if (user.id) {
	fetchEvacuationData();
	}
	}, [user.id]);
	return { latitude, longitude, evacuationData, error };
	};
	export default useGeolocation;
 
ДОДАТОК В
Код IoT-частини

В.1 Код скетчу IoT

	#include <WiFi.h>
	#include <WebSocketsClient.h>
	#include <LiquidCrystal_I2C.h>
	#include <ArduinoJson.h>
	const char* ssid = "Wokwi-GUEST";  // Wokwi default WiFi
	const char* password = "";         // No password
	#define MAC_ADDR "00-B0-D0-63-C2-26" // Corrected macro definition
	#define POT_PIN 19
	#define BTN_PIN 4
	#define LED_PIN 26
	#define BUZ_PIN 27 // Changed to a different pin for the buzzer
	WebSocketsClient webSocket;
	LiquidCrystal_I2C lcd(0x27, 20, 4); // Updated to 20x4 for larger display
	bool isWsConnected = false;
	bool isConfigReceived = false;
	bool isAlert = false; // flag for the state of the alert
	DynamicJsonDocument configData(1024); // To store the received configuration
	unsigned long previousMillis = 0; // Store the last time the message was sent
	const long interval = 5000; // Interval at which to send the message (milliseconds)
	float currentGas = 0.0; // Variable to store the current gas value
	float currentGasPrev = -1.0; // Initialize to an impossible value for the first comparison
	void setup() {
	Serial.begin(115200);

	pinMode(BTN_PIN, INPUT_PULLUP); // Button pin with internal pull-up resistor
	pinMode(LED_PIN, OUTPUT);       // LED pin
	pinMode(BUZ_PIN, OUTPUT);       // Buzzer pin
	pinMode(POT_PIN, INPUT);        // Potentiometer pin as input
	// Initialize LCD
	lcd.init();
	lcd.backlight();
	lcd.clear();
	lcd.setCursor(0, 0);
	lcd.print("Connecting to");
	lcd.setCursor(0, 1);
	lcd.print("WiFi...");
	// Connect to WiFi
	WiFi.begin(ssid, password);
	while (WiFi.status() != WL_CONNECTED) {
	delay(1000);
	Serial.println("Connecting to WiFi...");
	}
	Serial.println("Connected to WiFi");
	// Update LCD to show WiFi connection success
	lcd.clear();
	lcd.setCursor(0, 0);
	lcd.print("Connected to");
	lcd.setCursor(0, 1);
	lcd.print("WiFi!");
	// Connect to WebSocket server
	webSocket.begin("host.wokwi.internal", 8080, "/ws");  // Updated port to 8000
	webSocket.onEvent(webSocketEvent);
	webSocket.setReconnectInterval(5000); // Automatically try to reconnect every 5 seconds
	}
	void loop() {
	webSocket.loop(); // Handle WebSocket communication
	int buttonState = digitalRead(BTN_PIN);
	// Read the potentiometer value and map it to the range for gas level
	int potValue = analogRead(POT_PIN);
	currentGas = map(potValue, 0, 4095, 0, 100); // Map the potentiometer value (0-100)

	// Print the gas value only if it has changed
	if (currentGas != currentGasPrev) {
	Serial.println(currentGas);
	currentGasPrev = currentGas;
	}
	// Check if the gas value exceeds the limit or the button is pressed
	if (isConfigReceived && (currentGas >= configData["gasLimit"].as<float>() || buttonState == LOW)) {
	sendEmergencyAlert(); // Send emergency alert
	isAlert = true;
	} else {
	isAlert = false;
	}
	if (isAlert) {
	tone(BUZ_PIN, 2960);
	digitalWrite(LED_PIN, HIGH);   // Turn LED on
	lcd.clear();
	lcd.setCursor(0, 0);
	lcd.print("ALERT!");
	} else {
	noTone(BUZ_PIN);
	digitalWrite(LED_PIN, LOW);    // Turn LED off
	lcd.clear();
	}
	// Regular interval-based check
	unsigned long currentMillis = millis();
	if (currentMillis - previousMillis >= interval) {
	previousMillis = currentMillis;
	// Do not send an alert unless necessary, handled above
	}
	}
	// Request configuration values using the MAC address
	void requestConfigurationValues() {
	if (isWsConnected) {
	DynamicJsonDocument jsonDoc(1024); // Create a JSON document
	jsonDoc["type"] = "init"; // Initialization message type
	jsonDoc["MACADDR"] = MAC_ADDR; // Add MAC address to JSON document
	String request;
	serializeJson(jsonDoc, request); // Serialize JSON document to String
	webSocket.sendTXT(request); // Send the request over WebSocket
	}
	}
	// Send an emergency alert with the data received during initialization
	void sendEmergencyAlert() {
	if (isConfigReceived && isWsConnected) {
	DynamicJsonDocument jsonDoc(1024); // Create a JSON document
	jsonDoc["type"] = "emergencyAlert"; // Emergency alert message type
	jsonDoc["MACADDR"] = MAC_ADDR; // Add MAC address to JSON document
	jsonDoc["gasLimit"] = configData["gasLimit"];
	jsonDoc["defaultZoneRaduis"] = configData["defaultZoneRaduis"]; // Fix typo in the key name
	jsonDoc["longitude"] = configData["longitude"];
	jsonDoc["latitude"] = configData["latitude"];
	jsonDoc["currentGas"] = currentGas; // Include the current gas value
	String alertMessage;
	serializeJson(jsonDoc, alertMessage); // Serialize JSON document to String
	webSocket.sendTXT(alertMessage); // Send the emergency alert
	}
	}
	// Handle WebSocket events
	void webSocketEvent(WStype_t type, uint8_t * payload, size_t length) {
	switch (type) {
	case WStype_DISCONNECTED:
	Serial.println("WebSocket Disconnected");
	lcd.clear();
	lcd.setCursor(0, 0);
	lcd.print("WebSocket");
	lcd.setCursor(0, 1);
	lcd.print("Disconnected");
	isWsConnected = false;
	break;
	case WStype_CONNECTED:
	Serial.println("WebSocket Connected");
	lcd.clear();
	lcd.setCursor(0, 0);
	lcd.print("WebSocket");
	lcd.setCursor(0, 1);
	lcd.print("Connected");
	isWsConnected = true;
	// Request initial configuration values after connection
	requestConfigurationValues();
	break;
	case WStype_TEXT:
	// Print the received message
	Serial.print("Received message: ");
	Serial.write(payload, length);
	Serial.println();
	// Parse the received JSON message
	DynamicJsonDocument jsonDoc(1024);
	DeserializationError error = deserializeJson(jsonDoc, payload);
	if (error) {
	Serial.print("JSON parse error: ");
	Serial.println(error.c_str());
	return;
	}
	// Check and handle specific fields in the received JSON
	if (jsonDoc.containsKey("gasLimit")) {
	configData["gasLimit"] = jsonDoc["gasLimit"];
	}
	if (jsonDoc.containsKey("defaultZoneRaduis")) {
	configData["defaultZoneRaduis"] = jsonDoc["defaultZoneRaduis"];
	}

	if (jsonDoc.containsKey("longitude")) {
	configData["longitude"] = jsonDoc["longitude"];
	}
	if (jsonDoc.containsKey("latitude")) {
	configData["latitude"] = jsonDoc["latitude"];
	}
	// Mark configuration as received
	isConfigReceived = true;
	break;
	}
	}
 
ДОДАТОК Г
Діаграма активності IoT-частини


 
Рисунок Г.1 - Діаграма діяльності ІоТ частини
